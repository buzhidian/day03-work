<!DOCTYPE html>
<html lang="zh-CN">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>课堂</title>
</head>

<body>
    <div id="app">
    </div>
</body>
<script>
    // 将多维数组转化为一维
    let arr = [1,2,3,[5,6,8,9],12,[24,5,6]]
    let res = []

    function fn(arr,res) {
        arr.forEach(item=>{
            if (item instanceof Array) {
                fn(item,res)
            }else {
                res.push(item)
            }
        })
        return res
    }
    console.log(fn(arr,res));
    // console.log(arr instanceof Array);

    
    console.log("------分割线------");
    console.log("------分割线------");
    // 使用递归实现深拷贝
    function deepClone(obj) {
        // 判断类型
        if (obj == null) {  //null
            return obj
        }
        if (obj instanceof Date) {  //日期对象
            return new Date()
        }
        if (obj instanceof RegExp) {  //正则对象
            return new RegExp()
        }
        if (typeof obj !== "object") {
            return obj
        }
        let res = new obj.constructor()
        for (key in obj) {
            res[key] = deepClone(obj[key])
        }
        return res;
    }

    let obj1 = {
        name:"user",
        num:13,
        say:function(){
            console.log("这是方法");
        },
        obs:{
            color:"红色"
        }
    }
    console.log(obj1,"更改前的obj1");
    let obj2 = deepClone(obj1)
    obj2.num = 14
    obj2.say()
    obj2.obs.color = "黄色"
    console.log(obj1,"更改后的obj2");
    console.log(obj2,"obj2");

    let arr1 = deepClone(arr)
    console.log(arr1);


    console.log("------");
    /* function deepClone(obj) {
        if (obj == null) {
            return obj
        }
        if (obj instanceof Date) {
            return new Date()
        }
        if (obj instanceof RegExp) {
            return new RegExp()
        }
        if (typeof obj !== "object") {
            return obj
        }

        let res = new obj.constructor()

        for (key in obj){
            res[key] = deepClone(obj[key])
        }
        return res
        
    } */

   /*  function deepClone(obj) {
        if (obj == null) {
            return obj
        }
        if (obj instanceof Date) {
            return new Date()
        }
        if (obj instanceof RegExp) {
            return new RegExp()
        }
        if (typeof obj !== "object") {
            return obj
        }

        let res = new obj.constructor()

        for (key in obj){
            res[key] = deepClone(obj[key])
        }
        return res
    } */

    
    console.log("------分割线------");
    console.log("------分割线------");
    // 继承
    // 1.原型的继承
    // function Super() {
    //     this.a = [1,2]
    // }
    // Super.prototype.say = function () {
    //     console.log("添加的say方法");
    // }
    // function Sub(){}
    // Sub.prototype = new Super()

    // let test = new Sub()
    // console.log(test);
    // test.say()
    // console.log(test.a);
    // test.a.push(3)

    // let test2 = new Sub()
    // console.log(test2.a );


    /* function Super() {
        this.a
    }
    Super.prototype.say = function () {
        console.log("添加的方法");
    }
    function Sub(){}
    Sub.prototype = new Super()

    let test = new Sub()
    test.say() */

    /* function Super() {
        this.a
    }
    Super.prototype.say = function () {
        console.log("添加的方法");
    }
    function Sub(){}
    Sub.prototype = new Super()

    let test = new Sub()
    console.log(test);
    test.say() */

    console.log("----");
    // 2.盗用构造函数继承
    // function Super() {
    //     this.a = 1
    // }
    // Super.prototype.c = 3
    // function Sub(){
    //     Super.call(this)
    //     this.b = 2
    // }
    // let test = new Sub()
    // console.log(test,"test");
    // console.log(test.c);
    // let test1 = new Super()
    // console.log(test1,"test1");

    /* function Super() {
        this.a = 1
    }
    Super.prototype.c = 3
    function Sub(){
        Super.call(this)
        this.b = 2
    }
    let test = new Sub()
    console.log(test,"test");
    console.log(test.c);
    let test1 = new Super()
    console.log(test1,"test1"); */

    /* function Super() {
        this.a = 1
    }
    Super.prototype.c = 3
    function Sub(){
        Super.call(this)
        this.b = 2
    }
    let test = new Sub()
    console.log(test,"test");
    console.log(test.c);
    let test1 = new Super()
    console.log(test1,"test1"); */

    // 3.组合继承
    // function Super() {
    //     this.a = [1,2]
    // }
    // Super.prototype.say = function () {
    //     console.log("aaaaa");
    // }
    // function Sub() {
    //     Super.call(this)
    //     this.b = 12
    // }
    // Sub.prototype = new Super()

    // let test = new Sub()
    // test.say()
    // console.log(test,"test");

    // test.a.push(3)
    // let test1 = new Sub()
    // console.log(test1,"test1");

    /* function Super() {
        this.a = [1,2]
    }
    Super.prototype.say = function () {
        console.log("bbbb");
    }
    function Sub() {
        Super.call(this)
        this.b = 12
    }
    Sub.prototype = new Super()

    let test = new Sub()
    test.say()
    console.log(test,"test");

    test.a.push(3)
    let test1 = new Sub()
    console.log(test1,"test1"); */

    /* function Super() {
        this.a = [1,2]
    }
    Super.prototype.say = function () {
        console.log("bbb");
    }
    function Sub() {
        Super.call(this)
        this.b = 12
    }
    Sub.prototype = new Super()

    let test = new Sub()
    test.say()
    console.log(test,"test");

    test.a.push(3)
    let test1 = new Sub()
    console.log(test1,"test1"); */

    // 4.原型式继承
    // es5之前
    let obj3 = {a:1,b:2}
    function creatobj(obj) {
        function Fn(){}
        Fn.prototype = obj
        return new Fn()
    }

    let obj4 = creatobj(obj3)
    console.log(obj4);

    console.log("----");
    // es5之后
    let obj5 = Object.create(obj3)
    console.log(obj5);

    // es5之前
    /* let obj3 = {a:1,b:2}
    function creatobj(obj) {
        function Fn(){}
        Fn.prototype = obj
        return new Fn()
    }

    let obj4 = creatobj(obj3)
    console.log(obj4);

    console.log("----");
    // es5之后
    let obj5 = Object.create(obj3)
    console.log(obj5); */

    // es5之前
    /* let obj3 = {a:1,b:2}
    function creatobj(obj) {
        function Fn(){}
        Fn.prototype = obj
        return new Fn()
    }

    let obj4 = creatobj(obj3)
    console.log(obj4);

    console.log("----");
    // es5之后
    let obj5 = Object.create(obj3)
    console.log(obj5); */



    // 5/寄生式继承  ????
    function objectCopy(obj) {
        function Fn(){}
        Fn.prototype = obj
        return new Fn()
    }
    function createO(obj) {
        let clone = objectCopy(obj)
        clone.say=function(){
        console.log("hhhhh")
    }
        return clone
    }
    let obj6 = {a:3,b:4}
    let obj7 = createO(obj6)
    console.log(obj7);

    /* function createObj(o){
    let clone = objectCopy(o)
    clone.say=function(){
        console.log("hhhhh")
    }
    return clone
    }

    const obj = { a:1 }
    const test = createObj(obj) */


    // 6.寄生式组合继承
    // function Super(params) {
    //     this.a = [1,2]
    // }
    // Super.prototype.say = function () {
    //     console.log("111111");
    // }
    // function Sub() {
    //     Super.call(this)
    //     this.b = 3
    // }

    // Sub.prototype = Object.create(Super.prototype)
    // Sub.prototype.constructor = Sub

    // let test4 = new Sub()
    // console.log(test4,"test4");

    /* function Super(params) {
        this.a = [1,2]
    }
    Super.prototype.say = function () {
        console.log("111111");
    }
    function Sub() {
        Super.call(this)
        this.b = 3
    }

    Sub.prototype = Object.create(Super.prototype)
    Sub.prototype.constructor = Sub

    let test4 = new Sub()
    console.log(test4,"test4"); */

    /* function Super(params) {
        this.a = [1,2]
    }
    Super.prototype.say = function () {
        console.log("111111");
    }
    function Sub() {
        Super.call(this)
        this.b = 3
    }

    Sub.prototype = Object.create(Super.prototype)
    Sub.prototype.constructor = Sub

    let test4 = new Sub()
    console.log(test4,"test4"); */





    


</script>

</html>