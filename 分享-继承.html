<!DOCTYPE html>
<html lang="zh-CN">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>课堂</title>
</head>

<body>
    <div id="app">
    </div>
</body>
<script>
    // 继承方法
    // 1.原型的继承 
    /* function Super() {
        this.a = [1,2]
    }
    Super.prototype.say = function () {
        console.log("原型上添加的方法");
    }

    function Sub(){}
    Sub.prototype = new Super()

    let test = new Sub()
    test.say()
    test.a.push(3)

    console.log(test,"test");
    let test1 = new Sub()
    console.log(test1,"test1"); */

    // 2.盗用构造函数
   /*  function Super() {
        this.a = [1,2]
    }
    Super.prototype.c = 4
    function Sub() {
        Super.call(this)
        this.b = 2
    }

    let test = new Sub()
    console.log(test,"test"); */

    // 3.组合继承
    /* function Super() {
        this.a = [1,2]
    }
    Super.prototype.say = function () {
        console.log("原型上添加的方法");
    }

    function Sub(){
        Super.call(this)
        this.b = 13
    }
    Sub.prototype = new Super()

    let test = new Sub()
    test.say()
    
    test.a.push(3)
    console.log(test,"test");
    let test1 = new Sub()
    console.log(test1,"test1"); */

    // 4.原型式继承 
   /*  function creatO(obj) {
        function Fn() {}
        Fn.prototype = obj
        return new Fn()
    }

    let obj1 = {a:1,b:2}
    let obj2 = creatO(obj1)

    console.log(obj2); */

    // 5.寄生式继承
    

    // 6.寄生式组合继承
    function Super() {
        this.a = [1,2]
    }
    Super.prototype.say = function () {
        console.log("22131");
    }

    function Sub() {
        Super.call(this)
        this.b = 3
    }
    Sub.prototype = Object.create(Super.prototype)
    Sub.prototype.constructor = Sub

    let test = new Sub()
    console.log(test);


</script>

</html>